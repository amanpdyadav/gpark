package com.samsung.android.example.gparkprovider.service;import java.io.ByteArrayInputStream;import java.io.IOException;import java.security.cert.CertificateException;import java.security.cert.CertificateFactory;import java.text.DecimalFormat;import java.util.ArrayList;import java.util.Collections;import java.util.Comparator;import java.util.HashMap;import java.util.regex.Matcher;import java.util.regex.Pattern;import javax.security.cert.X509Certificate;import org.apache.http.HttpEntity;import org.apache.http.HttpResponse;import org.apache.http.client.ClientProtocolException;import org.apache.http.client.HttpClient;import org.apache.http.client.methods.HttpGet;import org.apache.http.impl.client.DefaultHttpClient;import org.apache.http.util.EntityUtils;import org.json.JSONArray;import org.json.JSONException;import org.json.JSONObject;import android.content.Context;import android.content.Intent;import android.content.pm.PackageInfo;import android.content.pm.PackageManager;import android.content.pm.PackageManager.NameNotFoundException;import android.content.pm.Signature;import android.location.Location;import android.net.Uri;import android.os.AsyncTask;import android.os.Binder;import android.os.IBinder;import android.text.format.Time;import android.util.Log;import android.widget.Toast;import com.google.android.gms.maps.model.LatLng;import com.samsung.android.sdk.SsdkUnsupportedException;import com.samsung.android.sdk.accessory.SA;import com.samsung.android.sdk.accessory.SAAgent;import com.samsung.android.sdk.accessory.SAAuthenticationToken;import com.samsung.android.sdk.accessory.SAPeerAgent;import com.samsung.android.sdk.accessory.SASocket;public class GParkProviderService extends SAAgent {	boolean executionComplete = false;	String dataTOBeSent = null;	ArrayList<ParkingList> parkListArray;	CurrentLocationService locationService;	Double radius;	String API = "AIzaSyDMzcM3kcFInzjF7hOJHQZ83V7DzVjUVLI";				public static final String TAG = "GparkProviderService";			public Boolean isAuthentication = false;			public Context mContext = null;			public static final int SERVICE_CONNECTION_RESULT_OK = 0;			public static final int GPARK_CHANNEL_ID = 104;			public static final int CHANNEL_ID_NAVIGATOR = 106;			HashMap<Integer, GParkProviderConnection> mConnectionsMap = null;			private final IBinder mBinder = new LocalBinder();			private String location;			public class LocalBinder extends Binder {				public GParkProviderService getService() {					return GParkProviderService.this;				}			}			public GParkProviderService() {				super(TAG, GParkProviderConnection.class);			}			public class GParkProviderConnection extends SASocket {				private int mConnectionId;				public GParkProviderConnection() {					super(GParkProviderConnection.class.getName());				}				@Override				public void onError(int channelId, String errorString, int error) {					Log.e(TAG, "Connection is not alive ERROR: " + errorString + "  "							+ error);				}				@Override				public void onReceive(int channelId, byte[] data) {					if (channelId == CHANNEL_ID_NAVIGATOR) {						String latlngData = new String(data);						startNaviagtor(latlngData);					} else if (channelId == GPARK_CHANNEL_ID) {												String[] words = (new String(data)).split(" ");						String sdata = words[0];						setRadius(Double.parseDouble(words[1]));												Log.d(TAG, "onReceive");						Time time = new Time();						time.set(System.currentTimeMillis());						String timeStr = " " + String.valueOf(time.minute) + ":"								+ String.valueOf(time.second);						String strToUpdateUI = new String(sdata);												Log.d(TAG, strToUpdateUI);						final String message = strToUpdateUI.concat(timeStr);						final GParkProviderConnection uHandler = mConnectionsMap.get(Integer								.parseInt(String.valueOf(mConnectionId)));						Log.d("Connection", "Gpark Connected");						if(uHandler == null){							Log.e(TAG,"Error, can not get GParkProviderConnection handler");							return;						}						new Thread(new Runnable() {							public void run() {								try {									while(!executionComplete) {										Thread thread = new Thread();										try {											Log.d(TAG, "waiting...");											thread.sleep(1000);										} catch (InterruptedException e) {											Log.e(TAG, e.toString());										}									}									if (dataTOBeSent != null && dataTOBeSent.length() <= 0 ) {										Log.d("Data sent :", "null");										uHandler.send(GPARK_CHANNEL_ID, message.getBytes());									}else {										Log.d("Data sent :", dataTOBeSent);										uHandler.send(GPARK_CHANNEL_ID, dataTOBeSent.getBytes());									}								} catch (IOException e) {									e.printStackTrace();								}							}						}).start();					}				}				private void startNaviagtor(String latlngData) {					Intent intent = new Intent(android.content.Intent.ACTION_VIEW, Uri.parse("http://maps.google.com/maps?" + "saddr="+ locationService.getLat() + "," + locationService.getLon() + "&daddr=" + latlngData));					if (isAppInstalled("com.google.android.apps.maps")) {						Log.d(TAG, "Has map app");						intent.setClassName("com.google.android.apps.maps", "com.google.android.maps.MapsActivity");						intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);					} else {						Toast.makeText(mContext, "No Map Activity", Toast.LENGTH_LONG).show();					}					startActivity(intent);				}				// helper function to check if Maps is installed				private boolean isAppInstalled(String uri) {					PackageManager pm = getApplicationContext().getPackageManager();					boolean app_installed = false;					try {						pm.getPackageInfo(uri, PackageManager.GET_ACTIVITIES);						app_installed = true;					} catch (PackageManager.NameNotFoundException e) {						app_installed = false;					}					return app_installed;				}				@Override				protected void onServiceConnectionLost(int errorCode) {					Log.e(TAG, "onServiceConectionLost  for peer = " + mConnectionId							+ "error code =" + errorCode);					if (mConnectionsMap != null) {						mConnectionsMap.remove(mConnectionId);					}				}			}			@Override			public void onCreate() {				super.onCreate();				Log.i(TAG, "onCreate of smart view Provider Service");				SA mAccessory = new SA();				try {					mAccessory.initialize(this);				} catch (SsdkUnsupportedException e) {					// Error Handling				} catch (Exception e1) {					Log.e(TAG, "Cannot initialize Accessory package.");					e1.printStackTrace();					/*					 * Your application can not use Accessory package of Samsung					 * Mobile SDK. You application should work smoothly without using					 * this SDK, or you may want to notify user and close your app					 * gracefully (release resources, stop Service threads, close UI					 * thread, etc.)					 */					stopSelf();				}			}	    			@Override 			protected void onServiceConnectionRequested(SAPeerAgent peerAgent) {				/*				 * The authenticatePeerAgent(peerAgent) API may not be working properly 				 * depending on the firmware version of accessory device. 				 * Recommend to upgrade accessory device firmware if possible.				 */    					isAuthentication = false;				if(isAuthentication) {					Toast.makeText(getBaseContext(), "Authentication On!", Toast.LENGTH_SHORT).show();					Log.e(TAG, "Start authenticatePeerAgent");					authenticatePeerAgent(peerAgent);				}				else {					Toast.makeText(getBaseContext(), "Authentication Off!", Toast.LENGTH_SHORT).show();					Log.e(TAG, "acceptServiceConnectionRequest");					acceptServiceConnectionRequest(peerAgent);					isAuthentication = true;				}			} 			protected void onAuthenticationResponse(SAPeerAgent uPeerAgent,					SAAuthenticationToken authToken, int error) {				if (authToken.getAuthenticationType() == SAAuthenticationToken.AUTHENTICATION_TYPE_CERTIFICATE_X509) {					mContext = getApplicationContext();					byte[] myAppKey = getApplicationCertificate(mContext);					if (authToken.getKey() != null) {						boolean matched = true;						if(authToken.getKey().length != myAppKey.length){							matched = false;						}else{							for(int i=0; i<authToken.getKey().length; i++){								if(authToken.getKey()[i]!=myAppKey[i]){									matched = false;								}							}						}										if (matched) {							acceptServiceConnectionRequest(uPeerAgent);							Log.e(TAG, "Auth-certification matched");						} else							Log.e(TAG, "Auth-certification not matched");							}				} else if (authToken.getAuthenticationType() == SAAuthenticationToken.AUTHENTICATION_TYPE_NONE) 					Log.e(TAG, "onAuthenticationResponse : CERT_TYPE(NONE)");					}			private static byte[] getApplicationCertificate(Context context) {				if(context == null) {					Log.e(TAG, "getApplicationCertificate ERROR, context input null");					return null;				}				Signature[] sigs;				byte[] certificat = null;				String packageName = context.getPackageName();				if (context != null) {					try {						PackageInfo pkgInfo = null;						pkgInfo = context.getPackageManager().getPackageInfo(								packageName, PackageManager.GET_SIGNATURES);						if (pkgInfo == null) {							Log.e(TAG, "PackageInfo was null!");							return null;						}						sigs = pkgInfo.signatures;						if (sigs == null) {							Log.e(TAG, "Signature obtained was null!");						} else {							CertificateFactory cf = CertificateFactory									.getInstance("X.509");							ByteArrayInputStream stream = new ByteArrayInputStream(									sigs[0].toByteArray());							X509Certificate cert;							cert = X509Certificate.getInstance(stream);							certificat = cert.getPublicKey().getEncoded();						}					} catch (NameNotFoundException e) {						// TODO Auto-generated catch block						e.printStackTrace();					} catch (CertificateException e) {						// TODO Auto-generated catch block						e.printStackTrace();					} catch (javax.security.cert.CertificateException e) {						// TODO Auto-generated catch block						e.printStackTrace();					}				}				return certificat;			}			@Override			protected void onFindPeerAgentResponse(SAPeerAgent arg0, int arg1) {				// TODO Auto-generated method stub				Log.d(TAG, "onFindPeerAgentResponse  arg1 =" + arg1);			}			@Override			protected void onServiceConnectionResponse(SASocket thisConnection,					int result) {				if (result == CONNECTION_SUCCESS) {					if (thisConnection != null) {						GParkProviderConnection myConnection = (GParkProviderConnection) thisConnection;						if (mConnectionsMap == null) {							mConnectionsMap = new HashMap<Integer, GParkProviderConnection>();						}						myConnection.mConnectionId = (int) (System.currentTimeMillis() & 255);						Log.d(TAG, "onServiceConnection connectionID = "								+ myConnection.mConnectionId);						mConnectionsMap.put(myConnection.mConnectionId, myConnection);						Log.e(TAG, "Connection Success");						//getCUrrentLocation						if (mContext == null) {							mContext = getApplicationContext();						}						new ReadURL().execute();						locationService = new CurrentLocationService(mContext);						location = locationService.getCurrentLocation();						Toast.makeText(mContext, location , Toast.LENGTH_LONG).show();					} else {						Log.e(TAG, "SASocket object is null");					}				} else if (result == CONNECTION_ALREADY_EXIST) {					Log.e(TAG, "onServiceConnectionResponse, CONNECTION_ALREADY_EXIST");				} else {					Log.e(TAG, "onServiceConnectionResponse result error =" + result);				}			}						@Override			public IBinder onBind(Intent arg0) {				return mBinder;			}			public class ReadURL extends AsyncTask<String, Integer, String> {								HttpClient client;				JSONArray jsonarray;				@Override				protected void onPostExecute(String result) {					StringBuilder parkList = new StringBuilder();					executionComplete = true;					Collections.sort(parkListArray, new CustomComparator());					parkList.append("[");					for(int i = 0; i < parkListArray.size(); i++) {						parkList.append(parkListArray.get(i).toString() + ",");					}					parkList.setLength(parkList.length() - 1);					parkList.append("]");										if (parkList.length() > 0) {						dataTOBeSent = parkList.toString();					}			 				}								public class CustomComparator implements Comparator<ParkingList> {				    @Override				    public int compare(ParkingList o1, ParkingList o2) {				        return o1.getDistance().compareTo(o2.getDistance());				    }				}								public JSONArray showPorts() throws ClientProtocolException, IOException,				JSONException {					HttpClient client = new DefaultHttpClient();						StringBuilder portURL = new StringBuilder(getUrl());					Log.d (TAG, getUrl());					HttpGet get = new HttpGet(portURL.toString());					HttpResponse r = client.execute(get);					int status = r.getStatusLine().getStatusCode();					if (status == 200) {						HttpEntity e = r.getEntity();						String data = EntityUtils.toString(e);						JSONObject jsonObject = new JSONObject(data);						JSONArray jarray = jsonObject.getJSONArray("results");						return jarray;					} else {						return null;					}				}				@Override				protected String doInBackground(String... params) {					try {						jsonarray = showPorts();						parkListArray  = new ArrayList<ParkingList>();						for (int i = 0; i < jsonarray.length(); i++) {							JSONObject object = jsonarray.getJSONObject(i);							ParkingList park = new ParkingList();							park.setName(object.getString("name"));							park.setAddress(object.getString("vicinity"));							LatLng lat = getStringvalue(object.getString("geometry"));							park.setLatitude(Double.toString(lat.latitude));							park.setLongitude(Double.toString(lat.longitude));							park.setDistance(distance(locationService.getLat(),locationService.getLon() , lat.latitude, lat.longitude));							parkListArray.add(park);							Log.d("Tag",park.toString());						}											} catch (ClientProtocolException e) {						// TODO Auto-generated catch block						e.printStackTrace();					} catch (IOException e) {						// TODO Auto-generated catch block						e.printStackTrace();					} catch (JSONException e) {						// TODO Auto-generated catch block						e.printStackTrace();					}					return null;				}				public LatLng getStringvalue(String str) {					Double first = 0.0;					Double second = 0.0;					Matcher m = Pattern.compile("(?!=\\d\\.\\d\\.)([\\d.]+)").matcher(str);					while (m.find()) {						if (first == 0) {							first = Double.parseDouble(m.group(1));						} else {							second = Double.parseDouble(m.group(1));						}					}					return new LatLng(second, first);				}			}							private double distance(double lat1, double lon1, double lat2, double lon2) {				DecimalFormat df2 = new DecimalFormat("###.##");				final float[] results = new float[3];				Location.distanceBetween(lat1, lon1, lat2, lon2, results);				return Double.valueOf(df2.format(results[0] / 1000));			}					public Double getRadius() {				if (radius == null){					return 2000.0;				}				else{				return radius;				}			}			public void setRadius(Double radius) {				this.radius = radius;			}			public String getUrl() {				return  "https://maps.googleapis.com/maps/api/place/nearbysearch/json?location="						+locationService.getLat()						+ ","						+ locationService.getLon()						+ "&radius="						+ getRadius()						+ "&types=parking&sensor=false&key=" + API;			}}